---
layout: skill
title: Couroutine - 비동기 작업을 위한 경량 Thread (Light-weight thread)
date: 2024-07-30
---




## Coroutine : Co + Routine

코루틴(coroutine)은 병행 프로그래밍을 지원하는 강력한 개념으로, 특히 비동기 작업을 보다 효율적으로 처리하는 데 유용합니다. 코루틴은 일반적인 함수나 루틴(routine)과 유사하지만, 실행을 중단하고 다른 작업을 수행할 수 있는 지점에서 중단된 상태를 기억할 수 있다는 점에서 다릅니다. 코루틴에서 `co`와 `routine`의 의미를 나누어 자세히 설명하면 다음과 같습니다.


코루틴은 일반 함수와 달리 호출 시 즉시 완료되지 않고, 필요한 시점에서 중단할 수 있으며, 다시 호출되었을 때 중단된 지점부터 실행을 재개합니다. 이는 주로 `yield`나 `suspend`와 같은 키워드를 사용하여 구현됩니다.


- Coroutine은 비슷한 기능을 제공하는 Rx(ReactiveX)보다 가벼우며, 더 간결하고 배우기 쉽습니다.


### Coroutine의 "Co-" : "together", "with"

: "함께", "공동으로", "동시에"

- **Cooperative**: 코루틴의 `co`는 협력적인(cooperative) 실행을 의미합니다. 코루틴은 자신이 실행되는 동안 언제든지 다른 코루틴에게 제어권을 넘길 수 있습니다. 이는 코루틴이 명시적으로 양보(yield)하는 방식으로 이루어집니다. 즉, 코루틴은 자신의 실행 흐름을 중단하고 다른 코루틴이 실행될 수 있도록 협력합니다.

- **Concurrency**: 코루틴은 동시성(concurrency)을 지원합니다. 코루틴은 여러 작업이 병행하여 실행되는 것처럼 보이지만, 실제로는 하나의 스레드에서 교대로 실행됩니다. 이는 전통적인 멀티스레딩과 달리 스레드 간의 컨텍스트 스위칭 오버헤드가 없고, 더 가벼운 리소스를 사용합니다.


### Coroutine의 "Routine" : "Code sequence for Specific task"
<!-- : "특정한 일을 실행하기 위한 일련의 명령" -->

- **Routine**: 루틴은 프로그램의 일부분으로, 특정 작업을 수행하는 코드 블록을 의미합니다. 일반적으로 함수나 메서드를 의미하며, 한 번 호출되면 끝날 때까지 계속 실행됩니다. 루틴은 시작부터 끝까지 일련의 순차적인 작업을 수행하는 데 집중합니다.

- **Functionality**: 코루틴도 루틴처럼 특정 작업을 수행하지만, 실행 도중 일시적으로 중단되었다가 다시 재개할 수 있는 기능을 가지고 있습니다. 이는 비동기 작업이나 이벤트 기반 프로그래밍에서 매우 유용합니다.



---




## Coroutine의 특징 및 장점


### 루틴 간 협력을 통한 비선점적 멀티태스킹



### 동시성 프로그래밍 지원




### 가독성 좋은 비동기 처리 Logic






---




## RX vs Coroutine







---




## Kotlin에서 Coroutine 사용하기

- Kotlin은 코루틴을 쉽게 사용할 수 있도록 `suspend` 함수와 `launch`, `async` 등의 빌더를 제공합니다.

```kotlin
emport kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        // launch 새로운 코루틴을 시작합니다.
        println("World!")
    }
    println("Hello,")
    // 코루틴은 runBlocking의 범위에서 실행됩니다.
}

suspend fun doSomething() {
    delay(1000L) // 1초 동안 중단
    println("Done!")
}

fun main() = runBlocking {
    // doSomething 코루틴을 실행
    doSomething()
}
```

위 예제에서는 `runBlocking`을 사용하여 코루틴을 블록 형태로 실행하고 있습니다. `launch`는 새로운 코루틴을 시작하며, `suspend` 함수는 일시 중단될 수 있는 함수입니다. `delay` 함수는 주어진 시간 동안 현재 코루틴을 중단시킵니다.

이 예제에서 코루틴은 협력적으로 실행되며, 특정 작업을 수행하기 위해 일시 중단하고, 다시 재개할 수 있는 기능을 보여줍니다. 이를 통해 비동기 작업을 보다 효율적으로 처리할 수 있습니다.




---
---
---
---
---
---
---
---
---
---
---
---
---
---
---

















- 실행의 지연과 재개를 허용함으로써, 비선점적 멀티태스킹을 위한 서브 루틴을 일반화한 컴퓨터 프로그램 구성 요소




커뮤니케이팅 시퀜셜 프로세스

커뮤니케이팅 시퀜셜 프로세스(Communicating Sequential Processes, CSP)는 병행 시스템에서 상호작용의 패턴을 기술하기 위해 고안된 형식 언어이다. 프로세스 대수 혹은 프로세스 계산이라 불리는 병행성 관련 수학논리의 한 종류이다. Go[1]와 같은 프로그래밍 언어의 디자인에 영향을 끼쳤다.

CSP는 1978년 앤터니 호어가 최초로 고안하여, 이후 계속해서 개량되어왔다. CSP는 여러 가지 시스템을 동시성의 관점에서 기술하여, 이를 파악하고 검증하기 위한 도구로 산업계에서 이용되고 있다.



### Coroutine의 "Co-" : "together", "with" :  "함께", "공동으로", "동시에"

- **co** : 를 의미합니다. 상호 연계 프로그램을 일컫는다고도 표현가능하다.


### Coroutine의 "Routine" : "특정한 일을 실행하기 위한 일련의 명령"

- coroutine은 루틴의 일종으로서, 협동 루틴이라 할 수 있습니다.

- 루틴과 서브 루틴은 서로 비대칭적인 관계이지만, 코루틴들은 완전히 대칭적인, 즉 서로가 서로를 호출하는 관계이다.

- 코루틴들에서는 무엇이 무엇의 서브루틴인지를 구분하는 것이 불가능하다.
    - 코루틴 A와 B가 있다고 할 때, A를 프로그래밍 할 때는 B를 A의 서브루틴으로 생각한다.
    - 그러나 B를 프로그래밍할 때는 A가 B의 서브루틴이라고 생각한다.
    - 어떠한 코루틴이 발동될 때마다 해당 코루틴은 이전에 자신의 실행이 마지막으로 중단되었던 지점 다음의 장소에서 실행을 재개한다.

Routine은 하나의 Task, Function 이라고 이해해도 될 것 같다. 보통 프로그램은 다양한 Routine들을 조합시켜 제작한다. Routine은 Main Routine과 Sub Routine으로 나뉘는데 Main Routine이 Sub Routine을 호출하는 방식이다. Coroutine 또한 Routine의 한 종류이지만 다음과 같은 특징이 있다.
- Main-Sub 개념을 구분하지 않는다. 그러므로 모든 Routine들이 서로를 호출할 수 있다.
- 진입과 탈출이 자유롭다. Sub Routine은 return을 만나야만 탈출할 수 있다



### Coroutine의 비선점적 멀티태스킹

컴퓨터구조에서 많이 들었던 개념인 것 같은데 비선점형은 하나의 태스크가 다른 태스크 가 실행 중이어도 프로세서(CPU)를 차지할 수 있다. 반대로 선점형은 하나의 태스크가 다른 태스크가 실행 중이라면 프로세서(CPU)를 차지할 수 없다.
코루틴은 비선점형 멀티태스킹, 스레드는 선점형 멀티태스킹이다. 그러므로 코루틴은 병행성(=-동시성)은 제공하고 병렬성은 제공하지 않는다.



### Coroutine을 사용하는 이유

개발을 하면서 가장 머리를 싸매는 순간은 어떤 코드를 동시에 처리를 해야 하는지, 반대로 그러면 안되는지를 결정하는 순간일 것이다. 여기서 결정한다고 하더라도 코드를 작성했을 때 동시에 처리를 하는 경우 순서에 따라 결과가 달라져 문제를 해결할 수 없는 경우가 다반사이다. 특히 Android에서는 UI를 그리는 작업, 데이터를 받아오는 작업을 동시에 수행하는 경우가 많기 때문에 이를 제어하기 위해서는 비동기 처리는 필수적이다.
그렇다고 기존에 비동기 처리를 위한 방법이 아예 없는 것은 아니었다. RxJava라는 것이 존재했다. 하지만 현재 Coroutine으로 대체되는 가장 큰 이유는 RxJava의 러닝커브가 상당하기 때문이다.






---


## Reference

- <https://ko.wikipedia.org/wiki/코루틴>
- <https://kotlinlang.org/docs/coroutines-basics.html>
- <https://dev.gmarket.com/82>