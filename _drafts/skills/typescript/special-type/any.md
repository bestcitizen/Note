---
layout: skill
title: TypeScript Special Type - Any ()
date: 2024-02-27
---





## `any` Type


TypeScript에서 `any` 타입은 가장 유연한 타입으로, 어떤 종류의 값도 할당할 수 있습니다. `any` 타입을 사용하면 TypeScript의 타입 검사 기능을 일시적으로 끌 수 있으므로, JavaScript와의 호환성을 유지하면서 점진적으로 타입스크립트를 도입하거나, 타입 정보가 없는 라이브러리를 사용할 때 유용합니다. 그러나 `any` 타입은 타입스크립트의 핵심 가치인 타입 안정성을 손상시킬 수 있기 때문에, 가능한 사용을 최소화하는 것이 좋습니다.

### `any` 타입의 특징

- **유연성**: `any` 타입 변수에는 문자열, 숫자, 배열, 객체 등 어떤 타입의 값도 할당할 수 있습니다.
- **타입 체크 우회**: `any` 타입을 사용하면, 해당 변수에 대한 컴파일 타임 타입 체크를 TypeScript 컴파일러가 수행하지 않습니다. 이는 동적 타입 언어의 특징을 유지하면서 타입스크립트를 사용하고자 할 때 유용할 수 있습니다.
- **타입 안정성 감소**: `any` 타입은 타입스크립트의 타입 시스템을 우회하기 때문에, 코드 내에서 타입 관련 오류가 발생할 가능성을 증가시킵니다. 타입 안정성이 중요한 프로젝트에서는 `any` 타입의 사용을 피하는 것이 좋습니다.

### `any` 타입 사용 예제

```typescript
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean

let looselyTyped: any = {};
let d = looselyTyped.a.b.c.d; // `any` 타입을 사용하면, 모든 하위 속성도 자동으로 `any` 타입이 됩니다.
```

### `any` 타입 사용시 주의사항

- **오버유즈 방지**: `any` 타입은 코드의 타입 안정성을 감소시키므로, 필요한 경우에만 제한적으로 사용해야 합니다.
- **적절한 타입 사용**: 가능한 경우, `unknown`, 제네릭, 유니온 타입 등 더 구체적인 타입을 사용하여 코드의 타입 안정성을 높이는 것이 좋습니다.
- **리팩토링 시 유의**: 기존 JavaScript 코드를 TypeScript로 마이그레이션하는 과정에서 `any` 타입을 사용할 수 있지만, 점진적으로 타입을 정확하게 명시하여 리팩토링하는 것이 중요합니다.

### 결론

`any` 타입은 TypeScript에서 타입 체크를 우회할 수 있는 강력한 도구이지만, 타입 안정성을 저해할 수 있기 때문에 신중하게 사용해야 합니다. 코드의 타입 안정성과 유지보수성을 유지하기 위해서는 `any` 타입 대신 더 명확한 타입을 사용하는 것이 바람직합니다.







`any` 타입의 사용과 관련하여 추가적인 내용을 더 제공할 수 있습니다. 이는 `any` 타입의 사용을 최소화하는 전략과 `any` 대신 고려할 수 있는 다른 타입스크립트의 타입들에 대한 정보입니다.

### `any` 타입 최소화 전략

- **점진적 타입 적용**: 기존 JavaScript 프로젝트를 TypeScript로 전환할 때, 초기에는 `any` 타입을 사용하여 컴파일 오류를 방지할 수 있습니다. 하지만, 프로젝트를 진행하면서 점진적으로 구체적인 타입으로 변경해 나가는 것이 중요합니다.
- **코드 리뷰 과정에서의 검토**: 코드 리뷰 과정에서 `any` 타입의 사용을 주의 깊게 검토하고, 가능한 구체적인 타입으로 대체할 수 있는지 확인합니다. 이는 팀 내에서 타입 안정성을 유지하는 데 도움이 됩니다.

### `any` 대신 고려할 수 있는 타입들

- **`unknown` 타입**: `any`와 유사하게 어떤 종류의 값도 할당할 수 있지만, `unknown` 타입에 할당된 변수를 사용하기 전에 해당 변수의 타입을 확인해야 합니다. 이는 타입 안정성을 높이는 데 도움이 됩니다.

  ```typescript
  let value: unknown;
  value = "Hello"; // OK
  value = 123; // OK
  
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // 타입 체크 후 사용
  }
  ```

- **제네릭 타입**: 함수나 클래스 등에서 입력 타입을 미리 정의하지 않고, 사용 시점에 타입을 결정할 수 있습니다. 제네릭을 사용하면 유연함을 유지하면서도 타입 안정성을 향상시킬 수 있습니다.

  ```typescript
  function identity<T>(arg: T): T {
    return arg;
  }
  
  let output = identity("myString"); // `output`는 `string` 타입
  ```

- **유니온 타입**: 두 개 이상의 타입 중 하나일 수 있는 변수의 타입을 지정할 때 사용합니다. 이는 `any` 타입보다 타입을 더 명확하게 제한할 수 있습니다.

  ```typescript
  let myVar: number | string;
  myVar = "Hello"; // OK
  myVar = 123; // OK
  ```

### 결론

`any` 타입은 타입스크립트의 타입 체크를 우회할 수 있는 유연한 도구이지만, 타입 안정성을 저해할 수 있으므로 신중하게 사용해야 합니다. 타입스크립트의 다양한 타입 시스템 기능을 활용하여 `any` 사용을 최소화하고, 프로젝트의 타입 안정성과 가독성을 향상시키는 것이 좋습니다.









## `any` Type을 사용할 수 없도록 설정하기


`noImplicitAny` 옵션은 TypeScript 프로젝트의 컴파일러 설정에서 매우 중요한 역할을 합니다. 이 옵션은 TypeScript의 타입 체커가 변수, 매개변수, 반환 값 등의 타입을 자동으로 `any`로 추론하지 못하게 막습니다. 즉, 개발자가 명시적으로 타입을 선언하지 않았을 때, 컴파일러가 오류를 발생시키도록 하는 기능입니다.

### `noImplicitAny` 옵션의 목적

- **타입 안정성 강화**: 명시적인 타입 선언을 강제함으로써 프로그램의 타입 안정성을 향상시킵니다.
- **`any` 사용 최소화**: 무분별한 `any` 타입의 사용을 방지하여, 코드의 가독성과 유지보수성을 높입니다.
- **버그 예방**: 타입 정보가 누락된 경우 오류를 발생시켜, 개발 초기 단계에서 버그를 예방할 수 있습니다.

### 사용 방법

`tsconfig.json` 파일에서 `noImplicitAny` 옵션을 `true`로 설정하여 활성화할 수 있습니다.

```json
{
  "compilerOptions": {
    "noImplicitAny": true
  }
}
```

### `noImplicitAny` 활성화 시 고려사항

- **코드 수정 필요성**: 이 옵션을 활성화하면 기존에 명시적 타입 선언이 없는 코드에서 컴파일 오류가 발생할 수 있습니다. 따라서, 해당 변수나 함수의 타입을 명시적으로 선언해야 합니다.
- **타입 선언의 중요성**: 때때로 타입을 명확히 정의하기 어려운 경우가 있습니다. 이런 경우, `any` 대신 `unknown` 타입을 사용하는 것이 좋으며, 필요에 따라 타입 가드나 타입 단언을 사용하여 타입을 좁혀나갈 수 있습니다.
- **외부 라이브러리 타입**: 외부 라이브러리를 사용하는 경우, 해당 라이브러리의 타입 정의가 없거나 불완전할 수 있습니다. 이런 상황에서는 DefinitelyTyped와 같은 커뮤니티에서 제공하는 `@types` 패키지를 활용하거나, 필요한 타입을 직접 선언할 수 있습니다.

### 결론

`noImplicitAny` 옵션은 타입스크립트의 강력한 타입 시스템을 최대한 활용하여, 코드의 안정성을 높이고 유지보수를 용이하게 하는 데 도움을 줍니다. 이 옵션을 통해 `any` 타입의 사용을 줄이고, 타입스크립트의 타입 추론 기능에 의존하지 않는 명확한 타입 선언을 장려함으로써, 보다 안정적인 소프트웨어 개발을 추구할 수 있습니다.