---
title: Transaction 격리 수준 - 동시성 제어를 위한 설정
layout: skill
date: 2024-10-11
---




## Transaction 격리 수준 : 동시성 제어를 위한 설정

- transaction의 **격리 수준(Isolation Level)은 동시에 여러 트랜잭션이 처리될 때 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 개념**입니다.
    - 격리 수준 설정을 통해 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정합니다.

- 격리 수준은 **데이터 무결성과 동시성 제어를 위해 필요**합니다.
    - **데이터 무결성 보장** : 트랜잭션이 동시에 실행될 때 발생할 수 있는 데이터 불일치나 충돌을 방지합니다.
    - **동시성 제어** : 여러 사용자가 동시에 데이터를 조작하는 상황에서 예측 가능한 동작을 보장합니다.
    - **성능과 무결성의 균형** : 너무 엄격한 격리 수준은 성능 저하를 초래할 수 있지만, 너무 느슨한 격리 수준은 데이터 무결성에 문제를 일으킬 수 있습니다.

- 데이터베이스는 ACID(Atomicity, Consistency, Isolation, Durability) 원칙을 따르며, **격리 수준은 그 중 Isolation을 구현하는 개념**입니다.
    - Isolation(격리성)은 여러 트랜잭션이 동시에 실행될 때 서로의 작업에 영향을 주지 않도록 독립적으로 수행되도록 보장하는 원칙이며, 이를 통해 데이터의 일관성과 무결성을 유지합니다.


### Isolation과 Locking의 필요성

- Isolation을 보장하기 위해, 데이터베이스는 Locking이라는 메커니즘을 사용합니다. 트랜잭션이 데이터에 접근할 때 Lock을 걸어 다른 트랜잭션이 해당 데이터에 동시에 접근하거나 수정하지 못하게 막습니다. 즉, 하나의 트랜잭션이 데이터에 대해 작업하는 동안 다른 트랜잭션은 그 데이터에 접근하지 못하도록 하여 데이터 충돌을 방지하는 것입니다.

성능과 Locking의 균형

하지만 모든 트랜잭션에 Lock을 무조건적으로 걸어 순차적으로 처리하게 되면 성능이 크게 저하될 수 있습니다. 동시에 많은 트랜잭션이 발생하는 시스템에서는 트랜잭션들이 서로 대기하는 시간이 길어지고, 이로 인해 성능 병목이 발생합니다.

효율적인 Locking의 필요성

반대로, 성능을 높이기 위해 Locking의 범위를 줄이거나 완화하게 되면 트랜잭션 간의 충돌이 발생할 수 있습니다. 트랜잭션이 작업 중인 데이터에 다른 트랜잭션이 접근하게 되어, 잘못된 값이 처리되거나 데이터 일관성이 깨질 수 있습니다.

따라서 성능과 데이터 무결성 간의 균형을 맞추기 위해 효율적인 Locking 방법이 필요합니다. 일반적으로 데이터베이스는 아래와 같은 다양한 최적화 기법을 사용하여 이 균형을 맞춥니다.

	•	Row-level Locking: 특정 행(row)에만 Lock을 걸어 다른 트랜잭션이 다른 행에 대해 동시에 작업할 수 있도록 허용하여 성능을 높입니다.
	•	Optimistic Locking: 충돌이 발생할 가능성이 낮을 때는 Lock을 걸지 않고 작업을 진행하고, 마지막에 충돌이 발생하면 다시 시도하는 방식입니다.
	•	Pessimistic Locking: 충돌 가능성이 높을 때는 트랜잭션 초기에 Lock을 걸고 다른 트랜잭션의 접근을 막는 방식입니다.

결국, 데이터베이스 시스템은 트랜잭션 간의 동시성을 최대화하면서도 데이터 일관성을 유지하기 위해 이러한 다양한 Locking 전략을 사용하여 성능을 최적화합니다.


<!-- 
- database는 ACID 중 Isolation에 따라 트랜잭션이 독립적인 수행을 하도록 설계되어 있습니다.
- 따라서 Locking을 통해 트랜잭션이 database를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요합니다.
- 하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면, DB의 성능은 떨어지게 됩니다.
- 그렇다고 성능을 높이기 위해 Locking의 범위를 줄인다면 잘못된 값이 처리될 문제가 발생하게 되므로, 최대한 효율적인 Locking 방법이 필요합니다.

- 트랜잭션이 database를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 Locking을 통해 막는 것이 필요합니다.
- 하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면, DB의 성능은 떨어지게 됩니다.
- 그렇다고 성능을 높이기 위해 Locking의 범위를 줄인다면 잘못된 값이 처리될 문제가 발생하게 되므로, 최대한 효율적인 Locking 방법이 필요합니다. -->


---




## 격리 수준의 종류

- 격리 수준은 크게 `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` 4가지로 구분됩니다.
    - `READ UNCOMMITTED`에서 `SERIALIZABLE`로 갈수록 트랜잭션 간 고립 정도가 높아지며 성능이 떨어지는 것이 일반적입니다.
    - 일반적인 온라인 서비스에서는 `READ COMMITTED` 나 `REPEATABLE READ` 중 하나를 사용합니다.
        - 예를 들어, Oracle의 default option은 `READ COMMITTED`이고, MySQL의 default option은 `REPEATABLE READ`입니다.


### Isolation Level 1. READ UNCOMMITTED



### Isolation Level 2. READ COMMITTED



### Isolation Level 3. REPEATABLE READ



### Isolation Level 4. SERIALIZABLE




---




## Reference

- <https://velog.io/@shasha/Database-transaction-정리>
