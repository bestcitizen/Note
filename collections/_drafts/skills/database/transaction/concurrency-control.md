---
layout: skill
title: 병행 제어 (Concurrency Control)
date: 2024-10-14
---




## 병행 제어 : 일관성과 효율성 모두 지키기

- **병행(concurrency)**은 매우 빠르게 여러 트랜잭션 사이를 이동하면서 조금씩 처리를 수행하는 방식입니다.
    - 실제로는 한 번에 한 트랜잭션만 수행하지만, 마치 동시에 여러 트랜잭션을 수행하는 것처럼 보이도록 합니다.

- **병행 제어(concurrency control)**는 여러 트랜잭션이 동시에 수행될 때 데이터베이스의 일관성과 무결성을 유지하기 위한 기법입니다.
    - 병행 트랜잭션들이 서로 영향을 미치지 않도록 제어하는 것이 목적입니다.
    - 데이터를 일관성 있게 유지하면서 동시에 여러 사용자가 데이터베이스를 최대한 공유할 수 있도록 합니다.

- 병행 제어는 데이터베이스의 **일관성**(데이터 무결성 유지)과 **효율성**(시스템 성능 최적화)이라는 **서로 상충되는 목적을 동시에 추구**합니다.
    - **데이터베이스의 일관성 유지** : 여러 트랜잭션이 동시에 실행되더라도 데이터베이스의 무결성과 일관성을 보장하여, 모든 트랜잭션이 완료된 후에도 데이터베이스가 정확하고 일관된 상태를 유지하도록 합니다.
    - **데이터베이스의 최대 공유** : 시스템의 자원을 효율적으로 활용하고 사용자 간의 데이터 공유를 최대화함으로써, 가능한 한 많은 사용자가 동시에 데이터베이스에 접근할 수 있도록 합니다.
    - **시스템 활용도 극대화** : 데이터베이스 시스템의 자원(CPU, 메모리, 디스크 등)을 최대한 효율적으로 사용하여 전체적인 시스템 성능을 향상시킵니다.
    - **사용자 응답 시간 최소화** : 각 트랜잭션의 실행 시간을 최소화하고 사용자가 요청한 작업에 대한 응답을 빠르게 받을 수 있도록 하여, 사용자 경험을 개선하고 시스템의 효율성을 높입니다.
    - **단위 시간당 처리할 수 있는 트랜잭션 수 최대화** : 주어진 시간 내에 처리할 수 있는 트랜잭션의 수를 늘려 시스템의 처리량(throughput)을 증가시킴으로써, 전체적인 시스템의 성능과 효율성을 높입니다.




---




## 병행 제어 없는 병행의 문제점

- 병행 제어 없이 병행 수행을 할 경우, 여러 트랜잭션이 동시에 데이터에 접근하고 수정할 때 다양한 문제들이 발생합니다.


### 갱신 분실 (Lost Update)

- 갱신 분실은 **두 개 이상의 트랜잭션이 동일한 데이터를 수정할 때 발생**하며, **한 트랜잭션의 갱신 결과가 다른 트랜잭션의 갱신에 의해 덮어쓰여서 일부 갱신이 소실되는 현상**을 말합니다.
    1. 트랜잭션 A와 B가 동시에 수량 데이터를 확인하고 각각 수정을 시도합니다.
    2. 두 트랜잭션 모두 수량이 1인 것을 확인합니다.
    3. 트랜잭션 A가 수정 요청을 보내고 수량을 1 감소시킵니다.
    4. 트랜잭션 B도 수정 요청을 보내고 수량을 1 감소시킵니다.
    5. 데이터베이스는 두 요청을 모두 처리하여 수량을 0으로 만듭니다.
    6. 실제로는 수량이 -1이 되어야 하지만, 트랜잭션 B의 갱신이 트랜잭션 A의 갱신을 덮어쓰게 되어 최종 수량은 0이 됩니다.

```mermaid
sequenceDiagram

participant a as 고객 A
participant b as 고객 B
participant db as Database

a ->> db : 재고 확인 (1개)
b ->> db : 재고 확인 (1개)
a ->> db : 구매 요청 (재고 -1)
b ->> db : 구매 요청 (재고 -1)
db ->> a : 구매 완료
db ->> b : 구매 완료
Note over db : 최종 재고 0개 (실제로는 -1개가 되어야 함)
```

- 예를 들어, 온라인 쇼핑몰에서 **두 명의 고객이 동시에 재고가 1개 남은 상품을 구매하려고 할 때** 갱신 분실 문제가 발생할 수 있습니다.
    - 고객 A와 고객 B가 동시에 상품의 재고를 확인하고, 각각 재고 1개를 기반으로 구매 요청을 보냅니다.
    - 데이터베이스는 두 요청을 처리하지만, 실제로는 한 요청만 처리되었어야 합니다.
    - 이로 인해 두 번째 트랜잭션의 갱신이 첫 번째 트랜잭션의 갱신을 덮어쓰며, 최종 재고가 실제보다 잘못 저장됩니다.
    - 고객 B의 구매로 인한 재고 감소가 '갱신 분실'되었습니다.
    - 이로 인해 데이터베이스의 일관성이 깨지고, 실제 재고보다 더 많은 상품이 판매되는 문제가 발생합니다.

- 갱신 분실 문제를 해결하기 위해서는 트랜잭션 격리 수준을 적절히 설정하거나, lock을 사용하여 동시 접근을 제어하는 등의 동시성 제어 기법을 적용해야 합니다.


### 모순성 (Inconsistency)

- 모순성은 여러 트랜잭션이 병행 수행될 때, **한 트랜잭션이 데이터를 수정하는 동안 다른 트랜잭션이 수정 중인 데이터를 읽어 참조**하면서 발생하는 불일치 문제를 말합니다.
    - 트랜잭션 1이 데이터를 갱신 중일 때, 트랜잭션 2가 그 데이터를 참조하면 불일치한 결과가 도출될 수 있습니다.

```mermaid
sequenceDiagram

participant t1 as Transaction 1
participant t2 as Transaction 2
participant db as Database

t1 ->> db : y에 500 더함
t2 ->> db : y에 4를 곱함
Note over db : 트랜잭션 2가 y에 4를 곱하기 전에 트랜잭션 1이 완료되었어야 함
```

- **두 개의 트랜잭션이 데이터 `y`를 각각 갱신하는 상황에서 모순성이 발생**할 수 있습니다.
    - 트랜잭션 1이 `y`에 500을 더하고, 그 이후에 트랜잭션 2가 `y`에 4를 곱해야 합니다.
    - 하지만 트랜잭션 2가 먼저 실행되어 `y`에 4를 곱한 후에 트랜잭션 1이 500을 더하는 상황이 발생할 수 있습니다.
    - 이는 데이터의 일관성을 해치며, 트랜잭션의 결과가 서로 모순(데이터 불일치)되게 됩니다.


### 연쇄 복귀 (Cascading Rollback)

- 연쇄 복귀는 **한 트랜잭션의 실패로 인해 다른 트랜잭션들이 함께 롤백되는 현상**입니다.
    - 병행 수행 중인 트랜잭션들이 서로 참조하고 있거나 상호 연관된 경우, 하나의 트랜잭션이 실패하면 다른 트랜잭션들도 영향을 받아 롤백될 수 있습니다.

- 트랜잭션 1이 데이터를 갱신하고, 그 데이터를 기반으로 트랜잭션 2가 수행되는 상황에서 연쇄 복귀가 발생할 수 있습니다.

```mermaid
sequenceDiagram

participant t1 as Transaction 1
participant t2 as Transaction 2
participant db as Database

t1 ->> db : 데이터 갱신
t2 ->> db : 갱신된 데이터 참조
t1 ->> db : 트랜잭션 1 실패로 인해 롤백
t2 ->> db : 트랜잭션 2도 롤백
```

- 트랜잭션 1이 실패하여 롤백되면, 트랜잭션 2는 이미 트랜잭션 1이 갱신한 데이터를 참조하고 있기 때문에 트랜잭션 2도 롤백되어야 합니다.

- 연쇄적인 롤백은 데이터 일관성 문제로 이어집니다.


### 현황 파악 오류 (Uncommitted Dependency)

- 현황 파악 오류는 **한 트랜잭션이 아직 커밋되지 않은 데이터를 다른 트랜잭션이 참조하면서 발생하는 문제**를 의미합니다.
    - 중간 상태의 데이터에 의존하여 잘못된 결과를 도출할 수 있는 위험을 동반합니다.

- 트랜잭션 1이 데이터를 갱신하고 있지만 아직 커밋되지 않은 상태에서 트랜잭션 2가 그 데이터를 참조하는 상황에서 현황 파악 오류가 발생할 수 있습니다.

```mermaid
sequenceDiagram

participant t1 as Transaction 1
participant t2 as Transaction 2
participant db as Database

t1 ->> db : 데이터 갱신 (미완료)
t2 ->> db : 미완료 데이터를 참조
t1 ->> db : 트랜잭션 1 실패
Note over t2 : 트랜잭션 2는 잘못된 데이터를 참조하여 잘못된 결과 도출
```

- 트랜잭션 1이 실패한 후에도 트랜잭션 2는 이미 실패한 데이터를 기반으로 연산을 수행했기 때문에, 트랜잭션 2 역시 오류를 내포할 수밖에 없습니다.

- 현황 파악 오류는 트랜잭션의 무결성과 신뢰성을 저하시킵니다.




---




## 병행 제어 기법

- 각 환경과 요구사항에 따라 적절한 병행 제어 기법을 선택하고 혼합하여, 데이터베이스의 일관성과 성능을 최적화할 수 있습니다.

| 기법 | 주요 특징 | 장점 | 단점 | 적합한 사용 상황 |
| --- | --- | --- | --- | --- |
| **Locking** | 데이터에 잠금을 걸어 독점적 사용 | - 데이터 일관성 보장<br>- 구현이 상대적으로 간단 | - 교착 상태 발생 가능<br>- 잠금 단위에 따른 성능 차이 | - 데이터 일관성이 매우 중요한 경우<br>- 트랜잭션 충돌이 빈번한 환경 |
| **Timestamp Ordering** | 트랜잭션에 타임스탬프 부여하여 순서대로 실행 | - 교착 상태 발생 없음<br>- 우선순위 부여 가능 | - Rollback 발생률 높음<br>- 연쇄 복귀 가능성 | - 트랜잭션 우선순위가 중요한 경우<br>- 교착 상태를 완전히 피해야 하는 상황 |
| **Optimistic Concurrency Control** | 트랜잭션 종료 후 검증 | - 충돌이 적은 환경에서 높은 성능<br>- 잠금 오버헤드 없음 | - 충돌 시 롤백 비용 높음<br>- 검증 단계에서 병목 현상 가능 | - 읽기 위주의 트랜잭션이 많은 환경<br>- 충돌 가능성이 낮은 상황 |
| **Multi-version Concurrency Control** | 데이터의 여러 버전 유지 | - 읽기 작업의 병행성 향상<br>- 롤백 감소 | - 저장 공간 증가<br>- 버전 관리 복잡성 | - 읽기와 쓰기 작업이 혼재된 환경<br>- 긴 트랜잭션과 짧은 트랜잭션이 공존하는 상황 |


### Locking : 잠금 기법

- Locking은 트랜잭션이 데이터를 독점적으로 사용하기 위해 **잠금을 걸어 다른 트랜잭션의 접근을 막는 기법**입니다.
    - 트랜잭션이 lock을 걸면 해당 데이터는 unlock될 때까지 독점적으로 사용됩니다.
    - 데이터의 잠금 단위는 필드, 레코드, 테이블 등으로 설정할 수 있습니다.
    - 이를 통해 상호 배제 기능을 제공하며, 잠금을 설정한 트랜잭션이 해제(unlock)할 때까지 데이터를 독점적으로 사용할 수 있습니다.
        - 상호 배제(mutual exclusion)는 여러 프로세스나 트랜잭션이 동시에 공유 자원에 접근하지 못하도록 하는 기법입니다.

- **한 번에 locking 할 수 있는 데이터의 크기**를 **locking 단위**라고 하며, field, record, table, file, database 모두 locking 단위가 될 수 있습니다.

- **locking 단위의 크기에 따라 병행성 수준과 성능의 차이가 발생**합니다.
    - 병행성 수준은 여러 트랜잭션이 동시에 실행될 수 있는 정도를 의미합니다.
    - **locking 단위가 클수록** 병행 제어가 단순해지고 관리하기가 편해지지만, 병행성 수준이 낮아집니다.
    - **locking 단위가 작을수록** 병행 제어가 복잡해지고 오버헤드가 증가하지만, 병행성 수준과 데이터베이스 공유도가 높아집니다. 

- locking 기법은 **교착 상태(deadlock)가 발생할 수 있다는 한계점**이 있습니다.
    - 교착 상태란 여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행을 하지 못하고 서로 무한정 기다리는 상태를 말합니다.
    - 예를 들어, Transaction 1에서 x를 lock 하고 Transaction 2에서 y를 lock 한 경우에 Transaction 1도 y에 접근할 수 없고 Transaction 2도 x에 접근할 수 없게 되기 때문에 서로 무한정 기다리게 됩니다.

- **locking의 종류에는 공유 잠금(S-lock)과 배타 잠금(X-lock)** 두 가지가 있으며, 둘 중 하나를 설정하는 기준은 읽기 연산(read)과 쓰기 연산(write)의 필요성에 따라 결정됩니다.
    - 읽기 연산(read)만 필요한 경우 공유 잠금을 설정하고, 쓰기 연산(write)이 필요한 경우 배타 잠금을 설정합니다.
    - 읽기와 쓰기 모두 필요한 경우에도 배타 잠금을 설정합니다.

| S-lock (공유 잠금) | X-lock (배타 잠금) |
| --- | --- |
| 읽기 연산(read)만 가능 | 읽기 연산(read)과 쓰기 연산(write) 모두 가능 |
| 다른 트랜잭션도 읽기 연산(read)만 가능 | 다른 트랜잭션은 읽기 연산(read)과 쓰기 연산(write) 모두 불가능 |
| 여러 트랜잭션이 동시에 공유 잠금을 설정할 수 있음 | 하나의 트랜잭션만이 배타 잠금을 설정할 수 있음 |


### Timestamp Ordering : 타임스탬프 순서 기법

- Timestamp Ordering 기법은 트랜잭션 간의 충돌을 방지하고 일관성을 유지하기 위해 트랜잭션의 **타임스탬프(Timestamp)**를 활용하는 방식입니다.
    - 트랜잭션의 실행 순서를 미리 지정된 타임스탬프에 따라 결정하는 방법으로, 직렬 가능성(serializability)을 보장합니다.
    - 트랜잭션이 시스템에 들어오는 시점을 기준으로 각각 고유한 타임스탬프를 부여받고, 이 타임스탬프에 따라 데이터베이스 연산이 수행됩니다.
    - timestamp는 데이터베이스에서 트랜잭션이 동시다발적으로 일어날 때, 그 순서에 대한 명확한 규칙을 제공합니다.

- 타임스탬프 순서 기법은 직렬 가능성을 보장하고 교착 상태를 방지할 수 있다는 장점이 있습니다.
    - **직렬 가능성 보장** : 타임스탬프를 통해 트랜잭션 간의 순서를 명확히 하여 직렬 가능한 스케줄을 보장할 수 있습니다.
    - **교착 상태 방지** : 트랜잭션 간에 자원 점유 대기 상태가 발생하지 않으므로 교착 상태(Deadlock)를 예방할 수 있습니다.

- 타임스탬프 순서 기법은 낙관적인 기법에 비해 비효율적이고 메모리 및 연산 비용이 높다는 단점이 있습니다.
    - **낙관적인 기법에 비해 비효율적** : 충돌이 자주 발생하면 트랜잭션을 자주 중단해야 하므로 비효율적일 수 있습니다.
    - **메모리 및 연산 비용** : 각 데이터 항목에 대해 Read Timestamp와 Write Timestamp를 지속적으로 관리해야 하므로 추가적인 메모리와 연산 자원이 필요합니다.


#### Timestamp Ordering 기법의 주요 개념

1. **Timestamp** : 트랜잭션이 시작될 때 시스템이 부여하는 고유한 숫자.
    - 타임스탬프는 트랜잭션의 상대적 실행 순서를 나타내며, 트랜잭션을 구분하고, 트랜잭션의 시작 순서를 보장하는 데 사용됩니다.
    - 타임스탬프에는 RTS와 WTS 두 가지 종류가 있습니다.
        - **Read Timestamp (RTS)** : 해당 데이터 항목을 가장 최근에 읽은 트랜잭션의 타임스탬프.
        - **Write Timestamp (WTS)** : 해당 데이터 항목을 가장 최근에 기록한 트랜잭션의 타임스탬프.

2. **Read Operation** : 읽기 연산.
    - 트랜잭션 \( T_i \)이 데이터 항목 \( X \)를 읽으려면 \( T_i \)의 타임스탬프 \( TS(T_i) \)가 데이터 항목 \( X \)의 Write Timestamp \( WTS(X) \)보다 커야 합니다. 즉, \( T_i \)가 \( X \)를 쓰기 연산한 다른 트랜잭션보다 나중에 실행된 트랜잭션이어야 합니다.
    - 만약 \( TS(T_i) < WTS(X) \)인 경우, 이는 \( X \)가 이미 \( T_i \)보다 최신 트랜잭션에 의해 갱신된 상태임을 의미하므로, \( T_i \)는 무효화되거나 중단됩니다.

3. **Write Operation** : 쓰기 연산.
   - 트랜잭션 \( T_i \)가 데이터 항목 \( X \)를 쓰려면 \( T_i \)의 타임스탬프 \( TS(T_i) \)가 \( X \)의 Read Timestamp \( RTS(X) \)와 Write Timestamp \( WTS(X) \) 모두보다 커야 합니다.
   - 만약 \( TS(T_i) < RTS(X) \)인 경우, 다른 트랜잭션이 이미 \( X \)를 읽었기 때문에 쓰기 연산이 거부됩니다.
   - 마찬가지로, \( TS(T_i) < WTS(X) \)인 경우, \( T_i \)는 \( X \)보다 나중에 발생한 쓰기 연산을 덮어쓸 수 없으므로 쓰기 연산이 거부됩니다.

4. **병행 제어 및 직렬 가능성 보장** : 타임스탬프를 기반으로 트랜잭션 우선순위 결정.
    - Timestamp Ordering 기법은 트랜잭션들이 데이터 항목에 대해 읽기 및 쓰기 연산을 수행하는 순서를 타임스탬프를 기반으로 결정함으로써, 트랜잭션 간의 충돌을 방지하고, 결과적으로 직렬 가능성을 보장합니다.
    - 만약 규칙을 위반하는 트랜잭션이 발생하면 해당 트랜잭션은 **중단**되거나 **재시작**되며, 일관성이 유지되도록 합니다.


### Optimistic Concurrency Control : 낙관적 병행 제어 기법

- 낙관적 병행 제어 기법(Optimistic Concurrency Control, OCC)은 트랜잭션 간의 충돌이 거의 발생하지 않을 것이라는 가정하에 설계된 병행 제어 기법입니다.
    - 트랜잭션이 수행되는 동안 충돌 감지를 하지 않고, 트랜잭션이 끝난 후에 충돌이 발생했는지 확인한 후 충돌이 발생하면 롤백을 수행하는 방식으로 병행 제어를 처리합니다.

- 낙관적 병행 제어 기법은 **잠금 없이 동작하고, 교착 상태 방지할 수 있으며, 오버헤드가 낮다는 장점**이 있습니다.
    - **잠금 없이 동작** : 트랜잭션 수행 중에 데이터 항목에 잠금을 걸지 않으므로, **잠금에 의한 병목 현상**이 발생하지 않습니다.
        - 따라서 충돌이 드문 환경에서 대체로 좋은 성능을 보입니다.
    - **교착 상태 방지** : 트랜잭션이 서로 자원을 점유하지 않으므로 **교착 상태(Deadlock)**가 발생하지 않습니다.
    - **낮은 오버헤드** : 잠금과 관련된 추가적인 비용이 없으므로, 트랜잭션의 처리 속도가 빨라질 수 있습니다.

- 낙관적 병행 제어 기법은 **충돌이 빈번한 환경에서 비효율적이고, 롤백 비용이 높으며, 대규모 데이터에 비효율적이라는 단점**이 있습니다.
    - **충돌이 빈번한 환경에서 비효율적** : 충돌이 자주 발생하면 트랜잭션이 검증 단계에서 자주 롤백될 수 있습니다.
        - 이는 트랜잭션의 재시도를 유발하고, 결과적으로 시스템의 **성능 저하**를 초래할 수 있습니다.
    - **롤백 비용** : 충돌이 발생할 경우 트랜잭션이 롤백되며, 트랜잭션이 수행한 모든 작업을 무효화해야 하므로 자원 낭비가 발생할 수 있습니다.
    - **대규모 데이터에 비효율적** : 데이터베이스에서 대규모의 트랜잭션이 동시다발적으로 발생할 때 충돌 가능성이 높아지며, 검증과 롤백에 대한 비용이 증가할 수 있습니다.

- 따라서 낙관적 병행 제어는 **트랜잭션 간의 충돌이 드물 것으로 예상되는 환경**에서 효과적입니다.
    - 트랜잭션 간 충돌이 적은 환경에서는 잠금과 관련된 오버헤드 없이 트랜잭션을 병행 처리할 수 있어 성능을 향상시킬 수 있습니다.
    - 충돌이 드문 경우 성능이 우수하지만, 충돌이 빈번한 환경에는 적합하지 않습니다.
    - 예를 들어, **읽기 위주**의 트랜잭션이 많은 시스템이나, **분산 시스템**에서 자주 사용됩니다.

#### OCC가 트랜잭션을 처리하는 세 단계

1. **트랜잭션 수행 단계 (Transaction Execution Phase)**.
    - 트랜잭션이 데이터 항목을 읽고, 변경을 메모리 상에서 수행하는 단계입니다.
    - 이 단계에서 데이터베이스의 실제 데이터는 변경되지 않고, 트랜잭션이 수정하려는 내용은 트랜잭션의 **로컬 작업 공간**에 기록됩니다.
    - 다른 트랜잭션과의 충돌을 고려하지 않고 자유롭게 작업을 수행할 수 있습니다.

2. **검증 단계 (Validation Phase)**.
    - 트랜잭션이 완료되면, 트랜잭션이 수행한 읽기 및 쓰기 연산이 다른 트랜잭션과 충돌하지 않았는지 검증합니다.
    - 이 단계에서 트랜잭션의 작업을 commit할 수 있는지 결정합니다. 충돌이 없으면 트랜잭션이 성공적으로 커밋되고, 충돌이 발생하면 트랜잭션이 롤백됩니다.
    - OCC는 트랜잭션 간의 타임스탬프를 기반으로 충돌을 감지하며, 주로 두 트랜잭션이 동일한 데이터 항목을 동시에 수정하려 할 때 충돌이 발생합니다.
    - 검증 단계에서 트랜잭션 간 충돌을 확인하기 위해 두 가지 기준을 사용합니다.
        - **읽기-쓰기 충돌** : 트랜잭션이 읽은 데이터 항목을 다른 트랜잭션이 동시에 수정하려 했는지 확인하며, 만약 충돌이 발생하면 트랜잭션은 롤백됩니다.
        - **쓰기-쓰기 충돌** : 트랜잭션이 동시에 동일한 데이터 항목을 수정하려는 경우 발생하는 충돌이며, 두 트랜잭션이 같은 데이터를 수정하려 할 때, 하나의 트랜잭션만 커밋되고 나머지는 롤백됩니다.

3. **쓰기 단계 (Write Phase)**.
    - 검증 단계에서 충돌이 없다고 판단되면, 트랜잭션의 작업 결과를 실제 데이터베이스에 반영합니다.
    - 트랜잭션이 사용했던 로컬 작업 공간의 데이터를 데이터베이스에 적용하여 변경 내용을 확정합니다.


### Multi-version Concurrency Control : 다중 버전 병행 제어 기법





---




## Reference

- <https://rebro.kr/163>
