---
layout: note
title: Clean Architecture - 객체 지향 설계 원칙(SOLID) 따르기
date: 2023-11-04
---



## 객체 지향적으로 Architecture를 설계하기

- 좋은 architecture를 만드는 일은 객체 지향(Object-Oriented, OO) 설계 원칙을 이해하고 응용하는 데에서 출발합니다.

- OO란?
    - 다형성을 이용하여 전체 system의 모든 source code 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
    - OO를 사용하면 Plugin Architect를 구성할 수 있음
        - 고수준의 정책을 포함하는 module은 저수준의 세부사항을 포함하는 module에 대해 독립성을 보장할 수 있음
        - 저수준의 세부사항은 중요도가 낮은 plugin module로 만들고, 고수준의 정책을 포함하는 module과는 독립적으로 개발하고 배포할 수 있음

- 다형성
    - 언제 어디서든 Plugin Architecture를 사용할 수 있게 해줌
    - 의존성 역전 (dependency inversion)
        - 원래(ex. C)는 source code의 의존성 방향은 반드시 제어흐름(flow of control)을 따르게 됨
            1. main 함수가 고수준 함수 호출
            2. 고수준 함수가 중간 수준 함수 호출
            3. 중간 수준 함수가 저수준 함수 호출
        - OO 언어는 다형성을 안전하고 편리하게 제공하므로 source code 의존성을 어디에서든 역전시킬 수 있음
            - source code 사이에 interface를 사용하여 제어흐름을 반대로 함
            - 즉, source code의 제어흐름과 의존성 방향에 대해 제한받지 않고 원하는 대로 설정할 수 있음

- OO에 대한 잘못된 설명
    - `Data와 함수의 조합`
        - o.f()가 f(o)와 다르다는 의미를 내포하기 때문에 정확한 설명이 아님
    - `실제 세계를 modeling하는 새로운 방법`
        - 의도가 불분명하며, 정의가 모호함
    - `OO는 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism) 이 세가지 개념을 적절하게 조합한 것`
        - 캡슐화 : C언어에서도 완벽한 캡슐화가 가능함 (data 구조와 함수를 header file에 선언하고 구현 file에서 구현)
            - 오히려 C++, C#, Java 등에서 완전한 캡슐화가 깨짐
                - C++ : compiler가 class의 instance 크기를 알아야 하기 때문에 class의 member 변수를 해당 class의 header file에 선언해야 함
                - C#, Java : 아예 header와 구현체를 분리하는 방식을 버렸음(class 선언과 정의를 구분하는 것이 불가능함)
        - 상속 : OO로 넘어와서 더 편리해지긴 했지만, C에서도 가능한 기법이었음
        - 다형성 : C에서 함수를 가리키는 pointer를 응용해 구현할 수 있었지만, OO는 이를 더 편리하고 안전하게 사용할 수 있게 해줌 (함수 pointer는 위험함)
            - OO에서 가장 중요한 부분 : 다형성을 통해 제어흐름을 간접적으로 전환하는 규칙을 부과함










[ 객체지향 프로그래밍 ]

구조적 프로그래밍보다 2년 전에 등장함(1966년 올레 요한 달, 크레스텐 니가드)
이들은 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역변수가 오래 유지될 수 있음을 발견함. 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 그리고 중첩 함수는 메소드가 됨
함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장하게 됨
객체지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과하는 패러다임
일반적으로 지역 변수는 스택 영역에 저장되며 함수 호출과 함께 소멸된다. 하지만 함수를 힙으로 옮기면 함수와 그 내부의 지역변수가 메모리 해제 전까지 계속해서 남아있게 된다. 그리고 이것이 객체의 기반이 되었다는 것이다.
"간접적인 전환에 대한 규칙을 부과한다"는 의미는 절자치향에서 다형성을 구현하기 위해 함수 포인터를 사용하는 것을 막는다는 뜻이다. 이 역시도 언어 차원에서 함수 포인터를 사용하지 않고 편리하게 다형성을 구현할 수 있도록 도와준다.
 
 



[ 서론 ]

좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는데서 출발함. 그렇다면 OO(Object-Oriented)란 무엇인가?
“데이터와 함수의 조합”
대체로 이런 방식으로 많이 설명되지만 그다지 만족스러운 대답은 아님
o.f()가 왠지 f(o)가 다르다는 의미를 내포하기 때문인데, OO의 발명 이전부터 프로그래머는 데이터를 함수에 전달해왔음
“실제 세계를 모델링하는 새로운 방법"
이는 얼버무리는 수준에 지나지 않음. “실제 세계를 모델링한다”는 것이 무엇을 의미하며, 왜 우리는 그 방향을 추구해야 하는가?
이 답변의 의도는 OO가 현실 세계와 의미적으로 가깝기 때문에 OO를 사용하면 소프트웨어를 조금 더 쉽게 이해할 수 있다는 데 있는듯 하지만 이 의도조차도 불분명하며, 그 정의가 너무 모호함
"캡슐화, 상속, 다형성을 기반으로 설명"
OO의 본질을 설명하기 위해 3가지(캡슐화, 상속, 다형성)에 기대기도 함
이들은 OO가 이 세 가지 개념을 적절하게 조합한 것이거나, OO 언어는 최소한 3가지 요소를 반드시 지원해야 한다고 함
여기서 o.f()는 f(o)와 같이 때문에 데이터와 함수의 조합으로 객체 지향을 설명하는 것이 부적절하다고 얘기한다. 앞서 살펴보았듯 객체라는 것도 결국 함수를 힙으로 옮긴 것(함수를 기반으로 만들어진 것)일 뿐이므로 사실상 차이가 없다는 뜻인 것 같다.
 
 
 
[ 캡슐화 ]

데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공하기 때문에 OO를 정의하는 요소 중 하나로 캡슐화가 언급됨
데이터와 함수가 응집력 있게 구성된 집단에서 데이터는 구분선 바깥에서 은닉되고, 일부 함수만이 외부에 노출됨
하지만 이는 OO가 아닌 언어에서도 충분히 가능하며, OO 언어에서 오히려 깨짐
실제로 많은 OO 언어가 캡슐화를 강제하지 않고, 단지 프로그래머가 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 함
실제로 OO 언어는 캡슐화를 강제하지 않는다. 다만 개발자가 이를 잘 사용할 것이라는 믿음 아래 진행된다. 하지만 우리의 코드를 생각해보면 public이 남용되는데, 과연 캡슐화가 OO의 핵심이라고 얘기할 수 있을까? 오히려 책에서 주어지는 예시 코드를 보면 C언어에서 캡슐화가 훨씬 잘 지켜짐을 확인할 수 있다.
 
 
 
 
[ 상속 ]

OO 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 확실히 제공했음
하지만 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과함
사실상 OO 언어가 있기 전에도 이를 구현하는 것은 가능했음. 물론 상속을 흉내내는 것이라 상속만큼 편리한 방식은 아님
그러므로 캡슐화에 대해서는 OO에 점수를 줄 수 없고, 상속에 대해서만 0.5점 정도 줄 수 있지만 이는 그저 그런 점수임
 
 
 
 
[ 다형성 ]

다형성 역시도 함수를 가리키는 포인터를 응용한 것일 뿐이며 OO가 새롭게 만든 것은 전혀 없음
대신 함수 포인터에 대한 직접적인 사용을 없애주고 실수할 위험을 줄임으로써, 다형성을 좀 더 안전하고 편리하게 사용할 수 있게 해줌
OO 언어에서 다형성은 쉽게 사용 가능하므로 OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있음
"제어흐름을 간접적으로 전환하는 규칙을 부과"는 함수의 포인터를 사용해 다형성을 사용하지 않는 것임을 파악할 수 있다.
 
 
 
 
[ 다형성이 가진 힘 ]

기존에는 함수를 가리키는 포인터를 사용하면 위험을 수반하기 때문에 이를 적용하지 않았었음
하지만 OO의 등장으로 다형성을 손쉽게 사용할 수 있게 되면서 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었음
플러그인 아키텍처란 인터페이스나 추상화된 객체에 의존함으로써 손쉽게 구현체를 바꿀 수 있는 아키텍처로 책의 뒷장에서 다시 한번 설명이 나온다.
 
 
 
 
[ 의존성 역전 ]

다형성을 안전하고 편리하게 적용할 수 있는 메커니즘이 등장하기 이전
소스 코드 의존성의 방향은 반드시 제어 흐름을 따르게 됨
main 함수가 고수준 함수를 호출하고, 고수준은 중간 수준 함수를, 중간 수준 함수는 저수준 함수를 호출함
이러한 제약 조건으로 인해 소프트웨어 아키텍트에게 남은 선택지는 별로 없었음
제어흐름은 시스템의 행위에 따라 결정되며, 소스코드 의존성은 제어흐름에 따라 결정됨
다형성 메커니즘이 등장한 이후
인터페이스를 통해 소스 코드 의존성이 제어 흐름과 반대가 될 수 있음. 이는 의존성 역전이라고 불림
OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 함
즉, 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정하는 절대적인 권한을 갖게 됨
즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않음. 호출하는 모듈이든 호출받는 모듈이든 원하는 방향으로 소스코드 의존성을 설정할 수 있음. 이것이 바로 OO가 제공하는 힘이며, OO가 지향하는 것
배포 독립성과 개발 독립성
비즈니스 로직, UI, DB는 배포 가능한 단위로 컴파일 가능하며, 비즈니스 로직은 UI와 DB 컴포넌트에 의존하지 않음
컴포넌트는 개별적이며 독립적으로 배포 가능함.
특정 컴포넌트의 소스 코드가 변경되면 해당 코드가 포함된 컴포넌트만 다시 배포하면 됨(배포 독립성)
시스템의 모듈을 독립적으로 배포할 수 있게 되면 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있음(개발 독립성)
기존의 계층형 아키텍처를 기준으로 다형성이 없는 상황을 살펴보도록 하자. 우리는 반드시 컨트롤러가 서비스를, 서비스가 레포지토리를 호출하면서 자연스럽게 데이터베이스가 중심이 될 수 밖에 없다. 하지만 레포지토리에 인터페이스를 만들고, 이를 서비스에 주입한다면 의존성의 방향이 데이터베이스가 아닌 서비스로 향하게 된다. 서비스는 비즈니스 로직과 연관된 계층이므로, 데이터베이스가 아닌 비즈니스 로직이 중심이 될 수 있는 것이다. 또한 협업을 할 때 인터페이스만 정의해둔다면 각각의 컴포넌트를 독립적으로 개발할 수 있다. 더 나아가 모듈까지 분리한다면 독립적으로 배포까지 가능하해진다. 즉, 다형성 덕분에 의존성의 방향을 제어할 수 있게된 것이다.
 
 
 
 
 
[ 결론 ]

OO란 다형성을 이용해 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 권한을 획득할 수 있는 능력임
OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 고수준의 정책을 포함하는 모듈이 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있음
저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있음
OO란 결국 다형성을 통해 의존성 방향을 제어할 수 있도록 하는 것이라고 설명해준다. 그만큼 의존성 방향은 중요하다.
 
 


 
 



























## SOLID 원칙



## 7장. SRP : Single Responsibility Principle : 단일 책임 원칙

```
콘웨이(conway) 법칙에 따른 따름정리 : software system이 가질 수 있는 최적의 구조는 system을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 software module은 변경의 이유가 하나, 단 하나여야만 한다.
```
- 하나의 module은 하나의, 오직 하나의 actor에 대해서만 책임져야 함
- 이 원칙을 위반하는 징후들
    1. 우발적 중복
        - 서로 다른 actor가 의존하는 code를 가까이 배치되는 경우
    2. 병합
        - 서로 다른 team에 속했을 개발자가 작업했을 때 변경 사항이 충돌하는 경우
- data와 method를 구분하고 퍼사드(Facade) pattern으로 해결


## 8장. OCP : Open-Closed Pinciple : 개방-폐쇄 원칙

```
1980년대에 버트란트 마이어(Bertrand Meyer)에 의해 유명해진 원칙이다. 기존 code를 수정하기보다는 반드시 새로운 code를 추가하는 방식으로 system의 행위를 변경할 수 있도록 설계해야만 software system을 쉽게 변경할 수 있다는 것이 이 원칙의 요지이다.
```
- software 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 함
    - software 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 됨
- system을 component 단위로 분리하고, 저수준 component에서 발생한 변경으로부터 고수준 component를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 함


## 9장. LSP : Liskov Subsitution Principle : 리스코프 치환 원칙

```
1988년 바바라 리스코프(Barbara Liskov)가 정의한, 하위 타입(subtype)에 관한 유명한 원칙이다. 요약하면, 상호 대체 가능한 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.
```
```
S type의 객체 o1 각각에 대응하는 T type 객체 o2가 있고, T type을 이용해서 정의한 모든 program P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는T의 하위 type이다.
```
- LSP는 architecture 수준까지 확장할 수 있고, 반드시 확장해야만 함
    - 치환 가능성을 조금이라도 위배하면 system architecture가 오염되어 상당량의 별도 mechanism을 추가해야할 수 있기 때문


## 10장. ISP : Interface Segregation Principle : 인터페이스 분리 원칙

```
이 원칙에 따르면 software 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
```


## 11장. DIP : Dependenvy Inversion Principle : 의존성 역전 원칙

```
고수준 정책을 구현하는 code는 저수준 세부사항을 구현하는 code에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.
```
- 유연성이 극대화된 system : 의존성이 추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는 system
    - Java같은 정적 type 언어에서 이 말은 use, import, include 구문은 오직 interface나 추상 class 같은 추상적인 선언만을 참조해야 한다는 뜻
        - 구체적인 요소에 의존할 수는 있지만 변동성이 큰(volatile) 구체적인 요소에는 절대로 의존해서는 안 됨

- 안정된 추상화
    - interface는 구현체보다 변경 가능성이 적으며 architect는 interface의 변동성을 낮추기 위해서 노력해야 함
    - 안정된 software architecture란?
        - 변동성이 큰 구현체에 의존하는 일은 지양함
        - 안정된 추상 interface에 의존하는 것을 선호함
    - 방법
        1. 변동성이 큰 구체 class를 참조하지 않기
            - 대신 추상 팩토리(Abstract Factory)를 사용하기
        2. 변동성이 큰 구체 class로부터 파생하지 않기
            - 상속은 아주 신중하기 사용하기
                - 상속은 source code의 모든 관계 중 가장 강력하고 뻣뻣하기 때문에 변경하기 어려움
        3. 구체 함수를 override하지 않기
            - 대체로 구체 함수는 source code 의존성을 필요로 함
                - 구체 함수를 override하면 이러한 의존성을 제거할 수 없게 됨 (의존성을 상속받게 되는 셈)
            - 차라리 추상 함수로 선언하고 구현체들에서 각잔의 용도에 맞게 구현하는 것이 나음
        4. 구체적이며 변동성이 크다면 그 이름을 언급하지 않기
            - DIP 원칙을 다른 방식으로 풀어쓴 말




---




# Reference

- Clean Architecture (도서) - Robert C. Martin
- <https://mangkyu.tistory.com/272>
