---
layout: note
title: Clean Code - 함수
version: 2023-04-18
---




- 작게 만들기
    - 명백해야 함
        - 각 함수가 이야기 하나를 표현하도록 해야 함
    - block과 들여쓰기
        - if 문 / else 문 / while 문 등에 들어가는 block은 한 줄이어야 함
            - 대개 여기서 함수를 호출함
            - 이렇게 하면 바깥을 감싸는 함수(enclosing function)가 작아짐
            - block안에서 호출하는 함수 이름을 적절히 짓는다면, code를 이해하기 쉬워짐
                - 중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻
            - == 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 됨

- 한 가지만 하기
    - '함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.'
    - 함수가 한 가지만 하는지  판단하는 방법
        - 한 함수 안(같은 추상화 수준)에서 logic을 추상화하여 한 단계만 수행하는 지 확인하기
        - 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있는지 확인하기
            - 한 가지 작업만 하는 함수는 자연스럽게 section으로나누기 어려움

- 함수 당 추상화 수준은 하나로 하기
    - 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 함
    - 한 함수 내에 추상화 수준을 섞으면 code를 읽는 사람이 헷갈리게 됨
        - 특정 표현이 근본 개념인지 세부사항인지 구분하기 어렵게 되기 때문
    - code는 위에서 아래로 이야기처럼 읽혀야 좋음

- Switch 문 (+ if/else 문)
    - switch 문은 작게 만들기 어려움
    - 본질적으로 switch 문은 N가지를 처리하기 때문에 '한 가지' 작업만 하도록 만들기 어려움
        - SRP(Single Responsibility Principle)를 위반함
            - code를 변경할 이유가 여럿이기 때문
        - OCP(Open Closed Principle)을 위반하게 함
            - 새로운 case를 추가할 때마다 code를 변경해야 하기 때문
    - 완전히 피할 방법은 없기 때문에, 각 switch 문을 저차원 class에 숨기고 반복하지 않는 방식을 사용하기
        - 다형성(polymorphism)을 이용하여 단 한 번만 사용하기
            - 다형적 객체를 생성하는 code 짜기
        - 숨긴 후에는 다른 code에 노출시키지 않음

- 서술적인 이름 사용하기
    - 'code를 읽으면서 짐작했던 기능을 각 routine이 그대로 수행한다면 깨끗한 code라 불러도 되겠다'
    - 함수가 작고 단순할수록 서술적인 이름을 고르기 쉬워짐
    - 이름이 길어도 괜찮음
        - '길고 서술적인 이름'이 '짧고 어려운 이름'보다 좋음
        - '길고 서술적인 이름'이 '길고 서술적인 주석'보다 좋음
    - 서술적인 이름을 사용하면 설계가 뚜렷해지므로 code 개선이 쉬워짐
    - 일관성 있는 이름을 붙여야 함
        - module 내에서 함수 이름은 같은 문구, 명사, 동사를 사용하기
            - ex) includeSetupAndTeardownPages, includSetupPages, includeSuiteSetupPage, includeSetupPage, ...

- 함수 인수
    - 인수 갯수는 적을수록 좋음
        - 0개 (무항) > 1개 (단항) > 2개 (이항) > 3개 (삼항) > 4개 이상 (다항)
    - 인수가 많으면
        - 개념을 이해하기 어려움
        - test case를 작성하기 어려움
    - 함수 이름과 인수는 추상화 수준이 같아야 함
    - 단항 형식을 사용할 때
        - 인수에 질문을 던지는 경우
        - 인수를 변환해 결과를 반환하는 경우
            - 입력 인수의 변환 결과는 반환값으로 돌려주기
                - 변환 결과를 가져오기 위해 출력 인수를 사용하는 것보다 반환값을 사용하는 것이 나음
            - 변환값으로 입력 인수를 그대로 돌려주는 함수여도, 변환 형태를 유지하기 위해 반환값으로 주는 것이 좋음
        - event 함수
            - ex) passwordAttemptFailedNtimes(int attempts)
            - event 함수는 event라는 사실이 code에 명확히 드러나야 함
    - flag 인수(boolean)는 사용하지 않음
        - 함수가 한꺼번에 여러 가지를 처리한다는 뜻이기 때문
            - flag가 참이면 a를 하고 거짓이면 b를 한다는 것이기 때문
    - 이항 함수
        - 적절한 경우 예
            - 인수가 x, y 좌표인 경우
        - 불가피하게 이항 함수를 사용할 수 있지만, 위험이 따르기 때문에 되도록이면 단항 함수를 사용해야 함
    - 인수 객체
        - 인수가 2~3개 필요하다면 일부를 독자적인 class 변수로 선언할 수도 있음
        - 객체를 생성해 인수를 줄일 수도 있음
            - 변수를 묶기 위해 이름을 붙여 개념을 표현하게 됨
    - 동사와 keyword
        - 단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야 함
            - `write(name)` 보다 `writeField(name)`이 더 나음
                - 한번에 알아보기 더 쉬움
        - 함수 이름에 keyword(인수 이름)를 추가하면 인수 순서를 기억할 필요가 없음
            - `assertEquals(expected, actual)`보다 `assertExpectedEqualsActual(expected, actual)`이 더 나음

- 부수 효과 일으키지 않기
    - 부수 효과는 그 자체로 거짓말이 됨
        - 함수에서 한 가지를 하는 척 하면서 다른 것도 하기 때문
    - 예상치 못하게 함수로 넘어온 인수나 class 변수, system 전역 변수를 수정하기도 함
    - 출력 인수를 사용하는 것은 피하기
        - `appendFooter(s);`
            - 이 함수가 s를 바닥글로 첨부할지, s에 바닥글을 첨부할지 알 수 없음
        - 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없음
            - 출력 인수로 사용하라고 설계한 `this`라는 변수가 있기 때문
                - `appendFooter(s)`보다 `report.appendFooter()`가 나음
        - 함수에서 상태를 변경해야 한다면, 함수가 속한 객체 상태를 변경하는 방식을 사용하는 것이 더 좋음

- 명령과 조회를 분리하기
    - 함수는 명령과 조회 중 하나만 해야 함

- 오류 code보다 예외를 사용하기
    - 오류 처리도 '한 가지 작업'이기 때문에, 오류를 처리하는 함수는 오류만 처리해야 함
    - `try-catch-finaly` 문 사용

- 반복하지 않기
    - 중복이 늘어나면, code 길이가 늘어나고, 수정 시 변경점이 많아짐
    - 중복을 없애면 module 가독성이 좋아짐
    - 많은 원칙과 기법, 기술이 중복을 제거하고 제어할 목적으로 나옴

- software를 짜는 행위는 글짓기와 비슷함
    - 생각을 기록한 후 읽기 좋게 다듬기
    - 초안은 서투르고 어수선하므로, 원하는 대로 읽힐 때까지 읽기 좋게 다듬음




---




# Reference

- Robert C. Martin, 『Clean Code』
